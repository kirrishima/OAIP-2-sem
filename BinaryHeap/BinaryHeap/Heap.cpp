#include "Heap.h"
#include <iostream>
#include <iomanip>
// Функцыя print() для вываду значэння элемента AAA.
void AAA::print()
{
	std::cout << x; // Вывад значэння x элемента AAA.
}

namespace heap
{
	// Функцыя для атрымання максімальнага элемента ў кучы без яго выдалення.
	void* Heap::getMax()
	{
		// Правяраем, ці не пустая куча.
		if (!isEmpty())
			// Вяртаем каранёвы элемент кучы (максімальны элемент).
			return storage[0];
		else
			// Калі куча пустая, вяртаем nullptr.
			return nullptr;
	}
	// Функцыя для атрымання мінімальнага элемента ў кучы без яго выдалення.
	void* Heap::getMin()
	{
		// Правяраем, ці не пустая куча.
		if (!isEmpty())
		{
			int minIndex = 0;
			// Шукаем мінімальны элемент сярод усіх элементаў кучы.
			for (int i = 1; i < size; ++i)
			{
				if (isLess(storage[i], storage[minIndex]))
					minIndex = i;
			}
			// Вяртаем знойдзены мінімальны элемент.
			return storage[minIndex];
		}
		else
		{
			// Калі куча пустая, вяртаем nullptr.
			return nullptr;
		}
	}
	// Функцыя для пошуку элемента ў кучы, які роўны суме максімальнага і мінімальнага элементаў.
	void* Heap::findSumElement()
	{
		// Правяраем, ці не пустая куча.
		if (!isEmpty())
		{
			// Атрымліваем максімальны і мінімальны элементы кучы.
			void* maxElement = getMax();
			void* minElement = getMin();

			// Правяраем, ці знойдзены максімальны і мінімальны элементы.
			if (maxElement != nullptr && minElement != nullptr)
			{
				// Вылічаем суму максімальнага і мінімальнага элементаў.
				int sum = ((AAA*)maxElement)->x + ((AAA*)minElement)->x;

				// Перабіраем элементы кучы для пошуку элемента, роўнага суме.
				for (int i = 0; i < size; ++i)
				{
					// Калі бягучы элемент роўны суме, вяртаем яго.
					if (((AAA*)storage[i])->x == sum)
						return storage[i];
				}
			}
		}

		// Калі не ўдалося знайсці элемент, роўны суме максімальнага і мінімальнага, вяртаем nullptr.
		return nullptr;
	}

	// Функцыя create() для стварэння кучы з зададзеным максімальным памерам і функцыяй параўнання.
	Heap create(int maxsize, CMP(*f)(void*, void*))
	{
		return *(new Heap(maxsize, f)); // Вяртае новую кучу з зададзенымі параметрамі.
	}

	// Функцыя left() для вылічэння індэкса левага нашчадка элемента ў кучы.
	int Heap::left(int ix)
	{
		return (2 * ix + 1 >= size) ? -1 : (2 * ix + 1); // Вяртае індэкс левага нашчадка.
	}

	// Функцыя right() для вылічэння індэкса правага нашчадка элемента ў кучы.
	int Heap::right(int ix)
	{
		return (2 * ix + 2 >= size) ? -1 : (2 * ix + 2); // Вяртае індэкс правага нашчадка.
	}

	// Функцыя parent() для вылічэння індэкса бацькоўскага элемента ў кучы.
	int Heap::parent(int ix)
	{
		return (ix + 1) / 2 - 1; // Вяртае індэкс бацькоўскага элемента.
	}

	// Функцыя swap() для абмену элементаў у кучы.
	void Heap::swap(int i, int j)
	{
		void* buf = storage[i]; // Часавая пераменная для захоўвання элемента.
		storage[i] = storage[j]; // Замена элемента на пазіцыі i элементам на пазіцыі j.
		storage[j] = buf; // Аднаўленне элемента на пазіцыі j з часовай зменнай.
	}

	// Функцыя heapify() для пераўтварэння паддрэва з коранем у вузле ix у кучу.
	void Heap::heapify(int ix)
	{
		int l = left(ix), r = right(ix), irl = ix; // Вылічэнне індэксаў левага і правага нашчадкаў.
		if (l > 0) // Праверка, ці існуе левы нашчадак.
		{
			if (isGreat(storage[l], storage[ix])) irl = l; // Калі левы нашчадак больш за бягучы вузл, абнаўляем індэкс максімуму.
			if (r > 0 && isGreat(storage[r], storage[irl])) irl = r; // Калі правы нашчадак больш за бягучы максімум, абнаўляем індэкс максімуму.
			if (irl != ix) // Калі азначнік максімуму адрозніваецца ад бягучага азначніка, выконваем абмен элементаў і рэкурсіўна выкліканы heapify().
			{
				swap(ix, irl); // Абмен бягучага вузла з вузлом максімуму.
				heapify(irl); // Выклік heapify для абноўленага вузла максімуму.
			}
		}
	}


	// Функцыя insert() для ўстаўкі новага элемента ў кучу.
	void Heap::insert(void* x)
	{
		int i;
		if (!isFull()) // Праверка на запоўненасць кучы.
		{
			storage[i = size++] = x; // Устаўка новага элемента ў кучу і павелічэнне памеру кучы.
			while (i > 0 && isLess(storage[parent(i)], storage[i])) // Падтрыманне ўласцівасці кучы пасля ўстаўкі новага элемента.
			{
				swap(parent(i), i); // Абмен элементаў, калі ўласцівасць кучы парушана.
				i = parent(i); // Пераход да бацькоўскага вузла.
			}
		}
	}

	// Функцыя extractMax() для вымання максімальнага элемента з кучы.
	void* Heap::extractMax()
	{
		void* rc = nullptr; // Ініцыялізацыя якое вяртаецца значэння.
		if (!isEmpty()) // Праверка на пустэчу кучы.
		{
			rc = storage[0]; // Захаванне максімальнага элемента.
			storage[0] = storage[size - 1]; // Перамяшчэнне апошняга элемента ў корань кучы.
			size--; // Памяншэнне памеру кучы.
			heapify(0); // Падтрыманне ўласцівасці кучы.
		}
		return rc; // Вяртанне вынятага максімальнага элемента.
	}

	// Функцыя scan() для вываду значэнняў элементаў кучы на экран.
	void Heap::scan(int i) const
	{
		int probel = 20; // Пачатковае значэнне для фарматавання вываду.
		std::cout << '\n'; // Пераход на новы радок.
		if (size == 0)
			std::cout << "Куча пустая"; // Выснова паведамлення аб пустой кучы.
		for (int u = 0, y = 0; u < size; u++)
		{
			std::cout << std::setw(probel + 10) << std::setfill(' '); // Фарматаваная выснова значэнняў элементаў.
			((AAA*)storage[u])->print(); // Выклік функцыі друку элемента AAA.
			if (u == y)
			{
				std::cout << '\n'; // Пераход на новы радок.
				if (y == 0)
					y = 2;
				else
					y += y * 2; // Павелічэнне кроку для фарматавання вываду.
			}
			probel /= 2; // Памяншэнне значэння для фарматавання вываду.
		}
		std::cout << '\n'; // Пераход на новы радок.
	}

	// Функция extractMin() для извлечения минимального элемента из кучи.
	void* Heap::extractMin()
	{
		void* rc = nullptr; // Инициализация возвращаемого значения.
		if (!isEmpty()) // Проверка на пустоту кучи.
		{
			int minIndex = 0; // Индекс минимального элемента, начинаем с 0.
			// Поиск минимального элемента среди дочерних элементов.
			for (int i = 1; i < size; ++i) {
				if (isLess(storage[i], storage[minIndex])) {
					minIndex = i; // Обновление индекса минимального элемента, если найден более маленький.
				}
			}

			rc = storage[minIndex]; // Сохранение минимального элемента перед удалением.

			storage[minIndex] = storage[size - 1]; // Замена минимального элемента последним элементом в куче.

			size--; // Уменьшение размера кучи.
			heapify(minIndex); // Поддержание свойства кучи после удаления минимального элемента.
		}
		return rc; // Возвращение извлеченного минимального элемента.
	}

	// Функцыя extractI() для выдалення элемента па зададзеным індэксе з кучы.
	void Heap::extractI(int i)
	{
		if (i < 0 || i >= size) // Праверка на карэктнасць індэкса.
		{
			std::cerr << "Index out of bounds." << std::endl; // Выснова паведамлення пра памылку.
			return; // Зварот з функцыі.
		}

		// Абмен элемента, які трэба выдаліць, з апошнім элементам, а затым падтрыманне ўласцівасці кучы.
		swap(i, size - 1);
		size--; // Памяншэнне памеру кучы.
		heapify(i); // Падтрыманне ўласцівасці кучы.
	}

	// Функцыя unionHeap() для аб'яднання двух куч.
	void Heap::unionHeap(Heap& h2)
	{
		for (int i = 0; i < h2.size; ++i) // Перабор элементаў другой кучы.
		{
			insert(h2.storage[i]); // Устаўка элементаў другой кучы ў бягучую кучу.
		}
		h2.size = 0; // Ачыстка другой кучы пасля аб'яднання.
	}
};